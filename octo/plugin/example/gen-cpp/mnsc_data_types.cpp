/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mnsc_data_types.h"



const char* MNSResponse::ascii_fingerprint = "65C8F5662964359B2CADB6CD5B9E7CEB";
const uint8_t MNSResponse::binary_fingerprint[16] = {0x65,0xC8,0xF5,0x66,0x29,0x64,0x35,0x9B,0x2C,0xAD,0xB6,0xCD,0x5B,0x9E,0x7C,0xEB};

uint32_t MNSResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultMNSCache.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            iprot->readListBegin(_etype3, _size0);
            this->defaultMNSCache.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->defaultMNSCache[_i4].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.defaultMNSCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MNSResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MNSResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.defaultMNSCache) {
    xfer += oprot->writeFieldBegin("defaultMNSCache", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultMNSCache.size()));
      std::vector<SGService> ::const_iterator _iter5;
      for (_iter5 = this->defaultMNSCache.begin(); _iter5 != this->defaultMNSCache.end(); ++_iter5)
      {
        xfer += (*_iter5).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* AppKeyListResponse::ascii_fingerprint = "93CC3D1E71866966C22792AABF4C3815";
const uint8_t AppKeyListResponse::binary_fingerprint[16] = {0x93,0xCC,0x3D,0x1E,0x71,0x86,0x69,0x66,0xC2,0x27,0x92,0xAA,0xBF,0x4C,0x38,0x15};

uint32_t AppKeyListResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->appKeyList.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            iprot->readListBegin(_etype9, _size6);
            this->appKeyList.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readString(this->appKeyList[_i10]);
            }
            iprot->readListEnd();
          }
          this->__isset.appKeyList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppKeyListResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AppKeyListResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.appKeyList) {
    xfer += oprot->writeFieldBegin("appKeyList", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->appKeyList.size()));
      std::vector<std::string> ::const_iterator _iter11;
      for (_iter11 = this->appKeyList.begin(); _iter11 != this->appKeyList.end(); ++_iter11)
      {
        xfer += oprot->writeString((*_iter11));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HttpPropertiesResponse::ascii_fingerprint = "ED513D89046EBA5323735F654E017436";
const uint8_t HttpPropertiesResponse::binary_fingerprint[16] = {0xED,0x51,0x3D,0x89,0x04,0x6E,0xBA,0x53,0x23,0x73,0x5F,0x65,0x4E,0x01,0x74,0x36};

uint32_t HttpPropertiesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->propertiesMap.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _ktype13;
            ::apache::thrift::protocol::TType _vtype14;
            iprot->readMapBegin(_ktype13, _vtype14, _size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              std::string _key17;
              xfer += iprot->readString(_key17);
              HttpProperties& _val18 = this->propertiesMap[_key17];
              {
                _val18.clear();
                uint32_t _size19;
                ::apache::thrift::protocol::TType _ktype20;
                ::apache::thrift::protocol::TType _vtype21;
                iprot->readMapBegin(_ktype20, _vtype21, _size19);
                uint32_t _i23;
                for (_i23 = 0; _i23 < _size19; ++_i23)
                {
                  std::string _key24;
                  xfer += iprot->readString(_key24);
                  std::string& _val25 = _val18[_key24];
                  xfer += iprot->readString(_val25);
                }
                iprot->readMapEnd();
              }
            }
            iprot->readMapEnd();
          }
          this->__isset.propertiesMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HttpPropertiesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HttpPropertiesResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.propertiesMap) {
    xfer += oprot->writeFieldBegin("propertiesMap", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->propertiesMap.size()));
      std::map<std::string, HttpProperties> ::const_iterator _iter26;
      for (_iter26 = this->propertiesMap.begin(); _iter26 != this->propertiesMap.end(); ++_iter26)
      {
        xfer += oprot->writeString(_iter26->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter26->second.size()));
          std::map<std::string, std::string> ::const_iterator _iter27;
          for (_iter27 = _iter26->second.begin(); _iter27 != _iter26->second.end(); ++_iter27)
          {
            xfer += oprot->writeString(_iter27->first);
            xfer += oprot->writeString(_iter27->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HlbcService::ascii_fingerprint = "2B0927C8450D9BBDBC550F84F98E1386";
const uint8_t HlbcService::binary_fingerprint[16] = {0x2B,0x09,0x27,0xC8,0x45,0x0D,0x9B,0xBD,0xBC,0x55,0x0F,0x84,0xF9,0x8E,0x13,0x86};

uint32_t HlbcService::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->failTimeout);
          this->__isset.failTimeout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxFails);
          this->__isset.maxFails = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slowStart);
          this->__isset.slowStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HlbcService::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HlbcService");
  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->weight);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.failTimeout) {
    xfer += oprot->writeFieldBegin("failTimeout", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->failTimeout);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxFails) {
    xfer += oprot->writeFieldBegin("maxFails", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->maxFails);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.slowStart) {
    xfer += oprot->writeFieldBegin("slowStart", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->slowStart);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HlbcHealthCheck::ascii_fingerprint = "4BF81DD46A7371532E49811022D58D36";
const uint8_t HlbcHealthCheck::binary_fingerprint[16] = {0x4B,0xF8,0x1D,0xD4,0x6A,0x73,0x71,0x53,0x2E,0x49,0x81,0x10,0x22,0xD5,0x8D,0x36};

uint32_t HlbcHealthCheck::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->healthCheckType);
          this->__isset.healthCheckType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->checkHttpSend);
          this->__isset.checkHttpSend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->legacyCheckCmd);
          this->__isset.legacyCheckCmd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HlbcHealthCheck::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HlbcHealthCheck");
  xfer += oprot->writeFieldBegin("healthCheckType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->healthCheckType);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.checkHttpSend) {
    xfer += oprot->writeFieldBegin("checkHttpSend", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->checkHttpSend);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.legacyCheckCmd) {
    xfer += oprot->writeFieldBegin("legacyCheckCmd", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->legacyCheckCmd);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HttpUpstream::ascii_fingerprint = "3D437A80A0D7D22F97D51104FD01693E";
const uint8_t HttpUpstream::binary_fingerprint[16] = {0x3D,0x43,0x7A,0x80,0xA0,0xD7,0xD2,0x2F,0x97,0xD5,0x11,0x04,0xFD,0x01,0x69,0x3E};

uint32_t HttpUpstream::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->upstreamName);
          this->__isset.upstreamName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->business);
          this->__isset.business = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->isGrey);
          this->__isset.isGrey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->scheduleStrategy.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _ktype29;
            ::apache::thrift::protocol::TType _vtype30;
            iprot->readMapBegin(_ktype29, _vtype30, _size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              std::string _key33;
              xfer += iprot->readString(_key33);
              std::string& _val34 = this->scheduleStrategy[_key33];
              xfer += iprot->readString(_val34);
            }
            iprot->readMapEnd();
          }
          this->__isset.scheduleStrategy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->server.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            iprot->readListBegin(_etype38, _size35);
            this->server.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->server[_i39].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->checkStrategy.read(iprot);
          this->__isset.checkStrategy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HttpUpstream::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HttpUpstream");
  xfer += oprot->writeFieldBegin("upstreamName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->upstreamName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("business", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->business);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("isGrey", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->isGrey);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.scheduleStrategy) {
    xfer += oprot->writeFieldBegin("scheduleStrategy", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->scheduleStrategy.size()));
      std::map<std::string, std::string> ::const_iterator _iter40;
      for (_iter40 = this->scheduleStrategy.begin(); _iter40 != this->scheduleStrategy.end(); ++_iter40)
      {
        xfer += oprot->writeString(_iter40->first);
        xfer += oprot->writeString(_iter40->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("server", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->server.size()));
    std::vector<HlbcService> ::const_iterator _iter41;
    for (_iter41 = this->server.begin(); _iter41 != this->server.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  if (this->__isset.checkStrategy) {
    xfer += oprot->writeFieldBegin("checkStrategy", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->checkStrategy.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* UpstreamDataResponse::ascii_fingerprint = "7B1356AE4AB9EE78A449977A5DB0A36D";
const uint8_t UpstreamDataResponse::binary_fingerprint[16] = {0x7B,0x13,0x56,0xAE,0x4A,0xB9,0xEE,0x78,0xA4,0x49,0x97,0x7A,0x5D,0xB0,0xA3,0x6D};

uint32_t UpstreamDataResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->upstreams.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _ktype43;
            ::apache::thrift::protocol::TType _vtype44;
            iprot->readMapBegin(_ktype43, _vtype44, _size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              std::string _key47;
              xfer += iprot->readString(_key47);
              HttpUpstream& _val48 = this->upstreams[_key47];
              xfer += _val48.read(iprot);
            }
            iprot->readMapEnd();
          }
          this->__isset.upstreams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UpstreamDataResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpstreamDataResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("upstreams", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->upstreams.size()));
    std::map<std::string, HttpUpstream> ::const_iterator _iter49;
    for (_iter49 = this->upstreams.begin(); _iter49 != this->upstreams.end(); ++_iter49)
    {
      xfer += oprot->writeString(_iter49->first);
      xfer += _iter49->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* UpstreamResponse::ascii_fingerprint = "20A57526680CA4CBC28C94966623FAC2";
const uint8_t UpstreamResponse::binary_fingerprint[16] = {0x20,0xA5,0x75,0x26,0x68,0x0C,0xA4,0xCB,0xC2,0x8C,0x94,0x96,0x66,0x23,0xFA,0xC2};

uint32_t UpstreamResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->upstreams.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _ktype51;
            ::apache::thrift::protocol::TType _vtype52;
            iprot->readMapBegin(_ktype51, _vtype52, _size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              std::string _key55;
              xfer += iprot->readString(_key55);
              std::string& _val56 = this->upstreams[_key55];
              xfer += iprot->readString(_val56);
            }
            iprot->readMapEnd();
          }
          this->__isset.upstreams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ext);
          this->__isset.ext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UpstreamResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpstreamResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("upstreams", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->upstreams.size()));
    std::map<std::string, std::string> ::const_iterator _iter57;
    for (_iter57 = this->upstreams.begin(); _iter57 != this->upstreams.end(); ++_iter57)
    {
      xfer += oprot->writeString(_iter57->first);
      xfer += oprot->writeString(_iter57->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ext", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ext);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HlbcLocation::ascii_fingerprint = "4BF81DD46A7371532E49811022D58D36";
const uint8_t HlbcLocation::binary_fingerprint[16] = {0x4B,0xF8,0x1D,0xD4,0x6A,0x73,0x71,0x53,0x2E,0x49,0x81,0x10,0x22,0xD5,0x8D,0x36};

uint32_t HlbcLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationPath);
          this->__isset.locationPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->locationBlockCmd);
          this->__isset.locationBlockCmd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxyPass);
          this->__isset.proxyPass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HlbcLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HlbcLocation");
  xfer += oprot->writeFieldBegin("locationPath", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->locationPath);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.locationBlockCmd) {
    xfer += oprot->writeFieldBegin("locationBlockCmd", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->locationBlockCmd);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proxyPass) {
    xfer += oprot->writeFieldBegin("proxyPass", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->proxyPass);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HlbcServer::ascii_fingerprint = "BD37D466633538819DD8ECA925A74220";
const uint8_t HlbcServer::binary_fingerprint[16] = {0xBD,0x37,0xD4,0x66,0x63,0x35,0x38,0x81,0x9D,0xD8,0xEC,0xA9,0x25,0xA7,0x42,0x20};

uint32_t HlbcServer::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverName);
          this->__isset.serverName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->business);
          this->__isset.business = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverBlockCmd);
          this->__isset.serverBlockCmd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->locationList.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            iprot->readListBegin(_etype61, _size58);
            this->locationList.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += this->locationList[_i62].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.locationList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HlbcServer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HlbcServer");
  xfer += oprot->writeFieldBegin("serverName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->serverName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("business", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->business);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.serverBlockCmd) {
    xfer += oprot->writeFieldBegin("serverBlockCmd", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->serverBlockCmd);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("locationList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->locationList.size()));
    std::vector<HlbcLocation> ::const_iterator _iter63;
    for (_iter63 = this->locationList.begin(); _iter63 != this->locationList.end(); ++_iter63)
    {
      xfer += (*_iter63).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ServerDataResponse::ascii_fingerprint = "EC2BC101620495291CDB8CA0CC8E7E14";
const uint8_t ServerDataResponse::binary_fingerprint[16] = {0xEC,0x2B,0xC1,0x01,0x62,0x04,0x95,0x29,0x1C,0xDB,0x8C,0xA0,0xCC,0x8E,0x7E,0x14};

uint32_t ServerDataResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->serverBlocks.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _ktype65;
            ::apache::thrift::protocol::TType _vtype66;
            iprot->readMapBegin(_ktype65, _vtype66, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              std::string _key69;
              xfer += iprot->readString(_key69);
              HlbcServer& _val70 = this->serverBlocks[_key69];
              xfer += _val70.read(iprot);
            }
            iprot->readMapEnd();
          }
          this->__isset.serverBlocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServerDataResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServerDataResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("serverBlocks", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serverBlocks.size()));
    std::map<std::string, HlbcServer> ::const_iterator _iter71;
    for (_iter71 = this->serverBlocks.begin(); _iter71 != this->serverBlocks.end(); ++_iter71)
    {
      xfer += oprot->writeString(_iter71->first);
      xfer += _iter71->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ServerBlockResponse::ascii_fingerprint = "20A57526680CA4CBC28C94966623FAC2";
const uint8_t ServerBlockResponse::binary_fingerprint[16] = {0x20,0xA5,0x75,0x26,0x68,0x0C,0xA4,0xCB,0xC2,0x8C,0x94,0x96,0x66,0x23,0xFA,0xC2};

uint32_t ServerBlockResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->serverBlocks.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _ktype73;
            ::apache::thrift::protocol::TType _vtype74;
            iprot->readMapBegin(_ktype73, _vtype74, _size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              std::string _key77;
              xfer += iprot->readString(_key77);
              std::string& _val78 = this->serverBlocks[_key77];
              xfer += iprot->readString(_val78);
            }
            iprot->readMapEnd();
          }
          this->__isset.serverBlocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ext);
          this->__isset.ext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServerBlockResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServerBlockResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("serverBlocks", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->serverBlocks.size()));
    std::map<std::string, std::string> ::const_iterator _iter79;
    for (_iter79 = this->serverBlocks.begin(); _iter79 != this->serverBlocks.end(); ++_iter79)
    {
      xfer += oprot->writeString(_iter79->first);
      xfer += oprot->writeString(_iter79->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ext", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ext);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


