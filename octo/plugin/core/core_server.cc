// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include "core_server.h"

#include <pthread.h>
#include <iostream>
#include <boost/make_shared.hpp>
#include <glog/logging.h>
#include <protocol/TBinaryProtocol.h>
#include <server/TNonblockingServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <concurrency/ThreadManager.h>
#include <concurrency/PosixThreadFactory.h>

#include "Core.h"
#include "host_manager.h"

using namespace std;
using namespace muduo;
using namespace muduo::net;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

namespace cplugin {

const char* kClientPort = "5288";
extern const char* g_cplugin_version;

class CoreHandler;

class CoreHandler : virtual public CoreIf {
 public:
  CoreHandler(HostManager* host_manager)
    : host_manager_(host_manager) {
    // Your initialization goes here
  }

    int32_t KeepAlive() {
        return host_manager_->KeepAlive();
    }

    int32_t Remove(const std::string& plugin_name, const int32_t plugin_id, const int32_t task_id){
        return host_manager_->Remove(plugin_name, plugin_id, task_id);
    }

    int32_t Start(const std::string& plugin_name, const int32_t plugin_id, const int32_t task_id) {
        return host_manager_->Start(plugin_name, plugin_id, task_id);
    }

    int32_t ReStart(const std::string& plugin_name, const int32_t plugin_id, const int32_t task_id) {
        return host_manager_->ReStart(plugin_name, plugin_id, task_id);
    }

    int32_t Stop(const std::string& plugin_name, const int32_t plugin_id, const int32_t task_id){
        return host_manager_->Stop(plugin_name, plugin_id, task_id);
    }

    int32_t Upgrade(const std::string& plugin_name, const std::string& plugin_version, const int32_t plugin_id, const int32_t task_id){
        return host_manager_->Upgrade(plugin_name, plugin_version, plugin_id, task_id);
    }

    int32_t StartNew(const std::string& plugin_name, const std::string& plugin_version, const int32_t plugin_id, const int32_t task_id){
        return host_manager_->StartNew(plugin_name, plugin_version, plugin_id, task_id);
    }

    int32_t RollBack(const std::string& plugin_name, const std::string& plugin_version, const int32_t plugin_id, const int32_t task_id){
        return host_manager_->RollBack(plugin_name,  plugin_version, plugin_id, task_id);
    }

    int32_t UpdateFile(const std::string& path, const std::string& content, const int32_t plugin_id, const int32_t task_id){
        return host_manager_->UpdateFile(path,  content, plugin_id, task_id);
    }

    int32_t notifyPluginAction(const std::vector<PluginAction> & plugin_list) {
        return host_manager_->notifyPluginAction(plugin_list);
    }

    void GetPluginInfos(std::map<std::string, TInfos> & _return) {
        return host_manager_->GetPluginInfos(_return);
    }

    void GetMonitorInfos(std::map<std::string, std::string> & _return, const std::vector<std::string> & agents){
        return host_manager_->GetMonitorInfos(_return, agents);
    }

    void GetVersion(std::string& _return) {
        _return = g_cplugin_version;
    }

 private:
  HostManager* host_manager_;;
};

CoreServer::CoreServer(HostManager* host_manager) 
  : host_manager_(host_manager) {
}

CoreServer::~CoreServer() {
}

bool CoreServer::Start() {
  int port = atoi(kClientPort);

  boost::shared_ptr<CoreHandler> handler(
      boost::make_shared<CoreHandler>(host_manager_));
  boost::shared_ptr<TProcessor> processor(
      boost::make_shared<CoreProcessor>(handler));
  boost::shared_ptr<TProtocolFactory> protocolFactory(
      boost::make_shared<TBinaryProtocolFactory>());

  boost::shared_ptr<ThreadManager> threadManager
      = ThreadManager::newSimpleThreadManager(1);
  boost::shared_ptr<PosixThreadFactory> threadFactory
      = boost::make_shared<PosixThreadFactory>();
  threadManager->threadFactory(threadFactory);
  threadManager->start();
  
  TNonblockingServer server(processor, protocolFactory, port, threadManager);

  try {
    server.serve();
  } catch(TException &e) {
    LOG(ERROR) << "Server start error.";
    return false;
  }
  return true;
}

} // namespace cplugin 
