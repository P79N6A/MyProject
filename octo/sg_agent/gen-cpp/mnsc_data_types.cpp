/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mnsc_data_types.h"



int _kProtocolsValues[] = {
  Protocols::THRIFT,
  Protocols::HTTP
};
const char* _kProtocolsNames[] = {
  "THRIFT",
  "HTTP"
};
const std::map<int, const char*> _Protocols_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kProtocolsValues, _kProtocolsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* MNSResponse::ascii_fingerprint = "0CDB7B27E1847CFA6E7D02796FA5A2DB";
const uint8_t MNSResponse::binary_fingerprint[16] = {0x0C,0xDB,0x7B,0x27,0xE1,0x84,0x7C,0xFA,0x6E,0x7D,0x02,0x79,0x6F,0xA5,0xA2,0xDB};

uint32_t MNSResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultMNSCache.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            iprot->readListBegin(_etype3, _size0);
            this->defaultMNSCache.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->defaultMNSCache[_i4].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.defaultMNSCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MNSResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MNSResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.defaultMNSCache) {
    xfer += oprot->writeFieldBegin("defaultMNSCache", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultMNSCache.size()));
      std::vector<SGService> ::const_iterator _iter5;
      for (_iter5 = this->defaultMNSCache.begin(); _iter5 != this->defaultMNSCache.end(); ++_iter5)
      {
        xfer += (*_iter5).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* MNSBatchResponse::ascii_fingerprint = "5CB5217E8D2AF6CB8C5C579D709D1AA6";
const uint8_t MNSBatchResponse::binary_fingerprint[16] = {0x5C,0xB5,0x21,0x7E,0x8D,0x2A,0xF6,0xCB,0x8C,0x5C,0x57,0x9D,0x70,0x9D,0x1A,0xA6};

uint32_t MNSBatchResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cache.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              std::string _key11;
              xfer += iprot->readString(_key11);
              std::map<std::string, std::vector<SGService> > & _val12 = this->cache[_key11];
              {
                _val12.clear();
                uint32_t _size13;
                ::apache::thrift::protocol::TType _ktype14;
                ::apache::thrift::protocol::TType _vtype15;
                iprot->readMapBegin(_ktype14, _vtype15, _size13);
                uint32_t _i17;
                for (_i17 = 0; _i17 < _size13; ++_i17)
                {
                  std::string _key18;
                  xfer += iprot->readString(_key18);
                  std::vector<SGService> & _val19 = _val12[_key18];
                  {
                    _val19.clear();
                    uint32_t _size20;
                    ::apache::thrift::protocol::TType _etype23;
                    iprot->readListBegin(_etype23, _size20);
                    _val19.resize(_size20);
                    uint32_t _i24;
                    for (_i24 = 0; _i24 < _size20; ++_i24)
                    {
                      xfer += _val19[_i24].read(iprot);
                    }
                    iprot->readListEnd();
                  }
                }
                iprot->readMapEnd();
              }
            }
            iprot->readMapEnd();
          }
          this->__isset.cache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MNSBatchResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MNSBatchResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.cache) {
    xfer += oprot->writeFieldBegin("cache", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->cache.size()));
      std::map<std::string, std::map<std::string, std::vector<SGService> > > ::const_iterator _iter25;
      for (_iter25 = this->cache.begin(); _iter25 != this->cache.end(); ++_iter25)
      {
        xfer += oprot->writeString(_iter25->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(_iter25->second.size()));
          std::map<std::string, std::vector<SGService> > ::const_iterator _iter26;
          for (_iter26 = _iter25->second.begin(); _iter26 != _iter25->second.end(); ++_iter26)
          {
            xfer += oprot->writeString(_iter26->first);
            {
              xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter26->second.size()));
              std::vector<SGService> ::const_iterator _iter27;
              for (_iter27 = _iter26->second.begin(); _iter27 != _iter26->second.end(); ++_iter27)
              {
                xfer += (*_iter27).write(oprot);
              }
              xfer += oprot->writeListEnd();
            }
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* AppKeyListResponse::ascii_fingerprint = "93CC3D1E71866966C22792AABF4C3815";
const uint8_t AppKeyListResponse::binary_fingerprint[16] = {0x93,0xCC,0x3D,0x1E,0x71,0x86,0x69,0x66,0xC2,0x27,0x92,0xAA,0xBF,0x4C,0x38,0x15};

uint32_t AppKeyListResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->appKeyList.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            iprot->readListBegin(_etype31, _size28);
            this->appKeyList.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readString(this->appKeyList[_i32]);
            }
            iprot->readListEnd();
          }
          this->__isset.appKeyList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppKeyListResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AppKeyListResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.appKeyList) {
    xfer += oprot->writeFieldBegin("appKeyList", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->appKeyList.size()));
      std::vector<std::string> ::const_iterator _iter33;
      for (_iter33 = this->appKeyList.begin(); _iter33 != this->appKeyList.end(); ++_iter33)
      {
        xfer += oprot->writeString((*_iter33));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HttpPropertiesResponse::ascii_fingerprint = "ED513D89046EBA5323735F654E017436";
const uint8_t HttpPropertiesResponse::binary_fingerprint[16] = {0xED,0x51,0x3D,0x89,0x04,0x6E,0xBA,0x53,0x23,0x73,0x5F,0x65,0x4E,0x01,0x74,0x36};

uint32_t HttpPropertiesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->propertiesMap.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _ktype35;
            ::apache::thrift::protocol::TType _vtype36;
            iprot->readMapBegin(_ktype35, _vtype36, _size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              std::string _key39;
              xfer += iprot->readString(_key39);
              HttpProperties& _val40 = this->propertiesMap[_key39];
              {
                _val40.clear();
                uint32_t _size41;
                ::apache::thrift::protocol::TType _ktype42;
                ::apache::thrift::protocol::TType _vtype43;
                iprot->readMapBegin(_ktype42, _vtype43, _size41);
                uint32_t _i45;
                for (_i45 = 0; _i45 < _size41; ++_i45)
                {
                  std::string _key46;
                  xfer += iprot->readString(_key46);
                  std::string& _val47 = _val40[_key46];
                  xfer += iprot->readString(_val47);
                }
                iprot->readMapEnd();
              }
            }
            iprot->readMapEnd();
          }
          this->__isset.propertiesMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HttpPropertiesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HttpPropertiesResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.propertiesMap) {
    xfer += oprot->writeFieldBegin("propertiesMap", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->propertiesMap.size()));
      std::map<std::string, HttpProperties> ::const_iterator _iter48;
      for (_iter48 = this->propertiesMap.begin(); _iter48 != this->propertiesMap.end(); ++_iter48)
      {
        xfer += oprot->writeString(_iter48->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter48->second.size()));
          std::map<std::string, std::string> ::const_iterator _iter49;
          for (_iter49 = _iter48->second.begin(); _iter49 != _iter48->second.end(); ++_iter49)
          {
            xfer += oprot->writeString(_iter49->first);
            xfer += oprot->writeString(_iter49->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* groupNode::ascii_fingerprint = "EEBC915CE44901401D881E6091423036";
const uint8_t groupNode::binary_fingerprint[16] = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

uint32_t groupNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t groupNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("groupNode");
  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HttpGroup::ascii_fingerprint = "9171212561229E2F5D704BD0F969D5C3";
const uint8_t HttpGroup::binary_fingerprint[16] = {0x91,0x71,0x21,0x25,0x61,0x22,0x9E,0x2F,0x5D,0x70,0x4B,0xD0,0xF9,0x69,0xD5,0xC3};

uint32_t HttpGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupName);
          this->__isset.groupName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appkey);
          this->__isset.appkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->server.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            iprot->readListBegin(_etype53, _size50);
            this->server.resize(_size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              xfer += this->server[_i54].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HttpGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HttpGroup");
  xfer += oprot->writeFieldBegin("groupName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->groupName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("appkey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->appkey);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("server", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->server.size()));
    std::vector<groupNode> ::const_iterator _iter55;
    for (_iter55 = this->server.begin(); _iter55 != this->server.end(); ++_iter55)
    {
      xfer += (*_iter55).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HttpGroupResponse::ascii_fingerprint = "0CB028ADABF804D8686CAE3020DF1C1B";
const uint8_t HttpGroupResponse::binary_fingerprint[16] = {0x0C,0xB0,0x28,0xAD,0xAB,0xF8,0x04,0xD8,0x68,0x6C,0xAE,0x30,0x20,0xDF,0x1C,0x1B};

uint32_t HttpGroupResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->groups.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _ktype57;
            ::apache::thrift::protocol::TType _vtype58;
            iprot->readMapBegin(_ktype57, _vtype58, _size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              std::string _key61;
              xfer += iprot->readString(_key61);
              HttpGroup& _val62 = this->groups[_key61];
              xfer += _val62.read(iprot);
            }
            iprot->readMapEnd();
          }
          this->__isset.groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HttpGroupResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HttpGroupResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->groups.size()));
    std::map<std::string, HttpGroup> ::const_iterator _iter63;
    for (_iter63 = this->groups.begin(); _iter63 != this->groups.end(); ++_iter63)
    {
      xfer += oprot->writeString(_iter63->first);
      xfer += _iter63->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* AllHttpGroupsResponse::ascii_fingerprint = "04212F4983C0C853711C659E324FC0FA";
const uint8_t AllHttpGroupsResponse::binary_fingerprint[16] = {0x04,0x21,0x2F,0x49,0x83,0xC0,0xC8,0x53,0x71,0x1C,0x65,0x9E,0x32,0x4F,0xC0,0xFA};

uint32_t AllHttpGroupsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->allGroups.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _ktype65;
            ::apache::thrift::protocol::TType _vtype66;
            iprot->readMapBegin(_ktype65, _vtype66, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              std::string _key69;
              xfer += iprot->readString(_key69);
              std::map<std::string, HttpGroup> & _val70 = this->allGroups[_key69];
              {
                _val70.clear();
                uint32_t _size71;
                ::apache::thrift::protocol::TType _ktype72;
                ::apache::thrift::protocol::TType _vtype73;
                iprot->readMapBegin(_ktype72, _vtype73, _size71);
                uint32_t _i75;
                for (_i75 = 0; _i75 < _size71; ++_i75)
                {
                  std::string _key76;
                  xfer += iprot->readString(_key76);
                  HttpGroup& _val77 = _val70[_key76];
                  xfer += _val77.read(iprot);
                }
                iprot->readMapEnd();
              }
            }
            iprot->readMapEnd();
          }
          this->__isset.allGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AllHttpGroupsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AllHttpGroupsResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("allGroups", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->allGroups.size()));
    std::map<std::string, std::map<std::string, HttpGroup> > ::const_iterator _iter78;
    for (_iter78 = this->allGroups.begin(); _iter78 != this->allGroups.end(); ++_iter78)
    {
      xfer += oprot->writeString(_iter78->first);
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter78->second.size()));
        std::map<std::string, HttpGroup> ::const_iterator _iter79;
        for (_iter79 = _iter78->second.begin(); _iter79 != _iter78->second.end(); ++_iter79)
        {
          xfer += oprot->writeString(_iter79->first);
          xfer += _iter79->second.write(oprot);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* MnsRequest::ascii_fingerprint = "38C252E94E93B69D04EB3A6EE2F9EDFB";
const uint8_t MnsRequest::binary_fingerprint[16] = {0x38,0xC2,0x52,0xE9,0x4E,0x93,0xB6,0x9D,0x04,0xEB,0x3A,0x6E,0xE2,0xF9,0xED,0xFB};

uint32_t MnsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast80;
          xfer += iprot->readI32(ecast80);
          this->protoctol = (Protocols::type)ecast80;
          this->__isset.protoctol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appkey);
          this->__isset.appkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->env);
          this->__isset.env = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MnsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MnsRequest");
  xfer += oprot->writeFieldBegin("protoctol", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protoctol);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("appkey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->appkey);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("env", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->env);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* RegisterResponse::ascii_fingerprint = "ABFA111458F19F7512E333E6D746DEE8";
const uint8_t RegisterResponse::binary_fingerprint[16] = {0xAB,0xFA,0x11,0x14,0x58,0xF1,0x9F,0x75,0x12,0xE3,0x33,0xE6,0xD7,0x46,0xDE,0xE8};

uint32_t RegisterResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->allowRegister);
          this->__isset.allowRegister = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RegisterResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RegisterResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.allowRegister) {
    xfer += oprot->writeFieldBegin("allowRegister", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->allowRegister);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.msg) {
    xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->msg);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


