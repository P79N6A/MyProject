/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "castle_data_types.h"



int _kErrorCodeValues[] = {
  ErrorCode::OK,
  ErrorCode::NO_CHANGE,
  ErrorCode::ILLEGAL_ROLE,
  ErrorCode::ILLEGAL_APPKEY,
  ErrorCode::ILLEGAL_TOPIC,
  ErrorCode::ILLEGAL_GROUP,
  ErrorCode::REGISTER_FAIL,
  ErrorCode::ILLEGAL_PARAM,
  ErrorCode::ILLEGAL_CLIENT_INFO,
  ErrorCode::ILLEGAL_CLIENT_CONFIG,
  ErrorCode::ILLEGAL_PRODUCER_CONFIG,
  ErrorCode::ILLEGAL_CONSUMER_CONFIG,
  ErrorCode::NO_VERSION_FOUND,
  ErrorCode::NO_TOPIC_CONFIG_FOUND,
  ErrorCode::NO_BROKER_FOUND,
  ErrorCode::NO_CLUSTER_FOUND,
  ErrorCode::NO_PARTITION_FOUND,
  ErrorCode::NO_PARTITION_ASSIGN,
  ErrorCode::OTHER_ERROR
};
const char* _kErrorCodeNames[] = {
  "OK",
  "NO_CHANGE",
  "ILLEGAL_ROLE",
  "ILLEGAL_APPKEY",
  "ILLEGAL_TOPIC",
  "ILLEGAL_GROUP",
  "REGISTER_FAIL",
  "ILLEGAL_PARAM",
  "ILLEGAL_CLIENT_INFO",
  "ILLEGAL_CLIENT_CONFIG",
  "ILLEGAL_PRODUCER_CONFIG",
  "ILLEGAL_CONSUMER_CONFIG",
  "NO_VERSION_FOUND",
  "NO_TOPIC_CONFIG_FOUND",
  "NO_BROKER_FOUND",
  "NO_CLUSTER_FOUND",
  "NO_PARTITION_FOUND",
  "NO_PARTITION_ASSIGN",
  "OTHER_ERROR"
};
const std::map<int, const char*> _ErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(19, _kErrorCodeValues, _kErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSendTypeValues[] = {
  SendType::SYNC,
  SendType::ASYN
};
const char* _kSendTypeNames[] = {
  "SYNC",
  "ASYN"
};
const std::map<int, const char*> _SendType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSendTypeValues, _kSendTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRequestTypeValues[] = {
  RequestType::ALL,
  RequestType::CONFIG,
  RequestType::MONITOR
};
const char* _kRequestTypeNames[] = {
  "ALL",
  "CONFIG",
  "MONITOR"
};
const std::map<int, const char*> _RequestType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kRequestTypeValues, _kRequestTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kClientRoleValues[] = {
  ClientRole::PRODUCER,
  ClientRole::CONSUMER
};
const char* _kClientRoleNames[] = {
  "PRODUCER",
  "CONSUMER"
};
const std::map<int, const char*> _ClientRole_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kClientRoleValues, _kClientRoleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* ClientInfo::ascii_fingerprint = "AB879940BD15B6B25691265F7384B271";
const uint8_t ClientInfo::binary_fingerprint[16] = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

uint32_t ClientInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          this->__isset.hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClientInfo");
  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ProducerConfig::ascii_fingerprint = "AB879940BD15B6B25691265F7384B271";
const uint8_t ProducerConfig::binary_fingerprint[16] = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

uint32_t ProducerConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appkey);
          this->__isset.appkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          this->__isset.topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->producerId);
          this->__isset.producerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProducerConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ProducerConfig");
  xfer += oprot->writeFieldBegin("appkey", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->appkey);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->topic);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("producerId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->producerId);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ConsumerConfig::ascii_fingerprint = "C93D890311F28844166CF6E571EB3AC2";
const uint8_t ConsumerConfig::binary_fingerprint[16] = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};

uint32_t ConsumerConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appkey);
          this->__isset.appkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          this->__isset.topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupName);
          this->__isset.groupName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->consumerId);
          this->__isset.consumerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumerConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConsumerConfig");
  xfer += oprot->writeFieldBegin("appkey", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->appkey);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->topic);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("groupName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->groupName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("consumerId", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->consumerId);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ClientConfig::ascii_fingerprint = "FD11DB73BD5F565E31AB00AFD25F5C2B";
const uint8_t ClientConfig::binary_fingerprint[16] = {0xFD,0x11,0xDB,0x73,0xBD,0x5F,0x56,0x5E,0x31,0xAB,0x00,0xAF,0xD2,0x5F,0x5C,0x2B};

uint32_t ClientConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->producerConfig.read(iprot);
          this->__isset.producerConfig = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->consumerConfig.read(iprot);
          this->__isset.consumerConfig = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClientConfig");
  xfer += oprot->writeFieldBegin("producerConfig", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->producerConfig.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("consumerConfig", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->consumerConfig.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* BrokerInfo::ascii_fingerprint = "52C6DAB6CF51AF617111F6D3964C6503";
const uint8_t BrokerInfo::binary_fingerprint[16] = {0x52,0xC6,0xDA,0xB6,0xCF,0x51,0xAF,0x61,0x71,0x11,0xF6,0xD3,0x96,0x4C,0x65,0x03};

uint32_t BrokerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BrokerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BrokerInfo");
  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ProducerClusterInfo::ascii_fingerprint = "DC66DD5698E10AD2C14B484BD17CCB09";
const uint8_t ProducerClusterInfo::binary_fingerprint[16] = {0xDC,0x66,0xDD,0x56,0x98,0xE1,0x0A,0xD2,0xC1,0x4B,0x48,0x4B,0xD1,0x7C,0xCB,0x09};

uint32_t ProducerClusterInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clusterName);
          this->__isset.clusterName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->brokerInfos.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            iprot->readListBegin(_etype3, _size0);
            this->brokerInfos.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->brokerInfos[_i4].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.brokerInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionList.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            iprot->readListBegin(_etype8, _size5);
            this->partitionList.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readI32(this->partitionList[_i9]);
            }
            iprot->readListEnd();
          }
          this->__isset.partitionList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProducerClusterInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ProducerClusterInfo");
  xfer += oprot->writeFieldBegin("clusterName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->clusterName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("brokerInfos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->brokerInfos.size()));
    std::vector<BrokerInfo> ::const_iterator _iter10;
    for (_iter10 = this->brokerInfos.begin(); _iter10 != this->brokerInfos.end(); ++_iter10)
    {
      xfer += (*_iter10).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("partitionList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->partitionList.size()));
    std::vector<int32_t> ::const_iterator _iter11;
    for (_iter11 = this->partitionList.begin(); _iter11 != this->partitionList.end(); ++_iter11)
    {
      xfer += oprot->writeI32((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ProducerResponse::ascii_fingerprint = "C8C902714AF61723C386021063B9871A";
const uint8_t ProducerResponse::binary_fingerprint[16] = {0xC8,0xC9,0x02,0x71,0x4A,0xF6,0x17,0x23,0xC3,0x86,0x02,0x10,0x63,0xB9,0x87,0x1A};

uint32_t ProducerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->kvPair.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _ktype13;
            ::apache::thrift::protocol::TType _vtype14;
            iprot->readMapBegin(_ktype13, _vtype14, _size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              std::string _key17;
              xfer += iprot->readString(_key17);
              std::string& _val18 = this->kvPair[_key17];
              xfer += iprot->readString(_val18);
            }
            iprot->readMapEnd();
          }
          this->__isset.kvPair = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->clusterInfoPair.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _ktype20;
            ::apache::thrift::protocol::TType _vtype21;
            iprot->readMapBegin(_ktype20, _vtype21, _size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              std::string _key24;
              xfer += iprot->readString(_key24);
              ProducerClusterInfo& _val25 = this->clusterInfoPair[_key24];
              xfer += _val25.read(iprot);
            }
            iprot->readMapEnd();
          }
          this->__isset.clusterInfoPair = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProducerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ProducerResponse");
  xfer += oprot->writeFieldBegin("kvPair", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kvPair.size()));
    std::map<std::string, std::string> ::const_iterator _iter26;
    for (_iter26 = this->kvPair.begin(); _iter26 != this->kvPair.end(); ++_iter26)
    {
      xfer += oprot->writeString(_iter26->first);
      xfer += oprot->writeString(_iter26->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("clusterInfoPair", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->clusterInfoPair.size()));
    std::map<std::string, ProducerClusterInfo> ::const_iterator _iter27;
    for (_iter27 = this->clusterInfoPair.begin(); _iter27 != this->clusterInfoPair.end(); ++_iter27)
    {
      xfer += oprot->writeString(_iter27->first);
      xfer += _iter27->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* PartitionAssign::ascii_fingerprint = "ACBC8ECF4940BD768FA35CCD08154770";
const uint8_t PartitionAssign::binary_fingerprint[16] = {0xAC,0xBC,0x8E,0xCF,0x49,0x40,0xBD,0x76,0x8F,0xA3,0x5C,0xCD,0x08,0x15,0x47,0x70};

uint32_t PartitionAssign::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->generationId);
          this->__isset.generationId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionList.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            iprot->readListBegin(_etype31, _size28);
            this->partitionList.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readI32(this->partitionList[_i32]);
            }
            iprot->readListEnd();
          }
          this->__isset.partitionList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionAssign::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PartitionAssign");
  xfer += oprot->writeFieldBegin("generationId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->generationId);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("partitionList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->partitionList.size()));
    std::vector<int32_t> ::const_iterator _iter33;
    for (_iter33 = this->partitionList.begin(); _iter33 != this->partitionList.end(); ++_iter33)
    {
      xfer += oprot->writeI32((*_iter33));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ConsumerClusterInfo::ascii_fingerprint = "38AE4D6DADC0E87BAA7EFEBC95A9EB34";
const uint8_t ConsumerClusterInfo::binary_fingerprint[16] = {0x38,0xAE,0x4D,0x6D,0xAD,0xC0,0xE8,0x7B,0xAA,0x7E,0xFE,0xBC,0x95,0xA9,0xEB,0x34};

uint32_t ConsumerClusterInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clusterName);
          this->__isset.clusterName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->brokerInfos.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            iprot->readListBegin(_etype37, _size34);
            this->brokerInfos.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->brokerInfos[_i38].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.brokerInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partitionAssign.read(iprot);
          this->__isset.partitionAssign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumerClusterInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConsumerClusterInfo");
  xfer += oprot->writeFieldBegin("clusterName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->clusterName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("brokerInfos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->brokerInfos.size()));
    std::vector<BrokerInfo> ::const_iterator _iter39;
    for (_iter39 = this->brokerInfos.begin(); _iter39 != this->brokerInfos.end(); ++_iter39)
    {
      xfer += (*_iter39).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("partitionAssign", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->partitionAssign.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ConsumerResponse::ascii_fingerprint = "A7BFB88BFC70E3646F8AA011B2EEC05A";
const uint8_t ConsumerResponse::binary_fingerprint[16] = {0xA7,0xBF,0xB8,0x8B,0xFC,0x70,0xE3,0x64,0x6F,0x8A,0xA0,0x11,0xB2,0xEE,0xC0,0x5A};

uint32_t ConsumerResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->kvPair.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _ktype41;
            ::apache::thrift::protocol::TType _vtype42;
            iprot->readMapBegin(_ktype41, _vtype42, _size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              std::string _key45;
              xfer += iprot->readString(_key45);
              std::string& _val46 = this->kvPair[_key45];
              xfer += iprot->readString(_val46);
            }
            iprot->readMapEnd();
          }
          this->__isset.kvPair = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->clusterInfoPair.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _ktype48;
            ::apache::thrift::protocol::TType _vtype49;
            iprot->readMapBegin(_ktype48, _vtype49, _size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              std::string _key52;
              xfer += iprot->readString(_key52);
              ConsumerClusterInfo& _val53 = this->clusterInfoPair[_key52];
              xfer += _val53.read(iprot);
            }
            iprot->readMapEnd();
          }
          this->__isset.clusterInfoPair = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumerResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConsumerResponse");
  xfer += oprot->writeFieldBegin("kvPair", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->kvPair.size()));
    std::map<std::string, std::string> ::const_iterator _iter54;
    for (_iter54 = this->kvPair.begin(); _iter54 != this->kvPair.end(); ++_iter54)
    {
      xfer += oprot->writeString(_iter54->first);
      xfer += oprot->writeString(_iter54->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("clusterInfoPair", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->clusterInfoPair.size()));
    std::map<std::string, ConsumerClusterInfo> ::const_iterator _iter55;
    for (_iter55 = this->clusterInfoPair.begin(); _iter55 != this->clusterInfoPair.end(); ++_iter55)
    {
      xfer += oprot->writeString(_iter55->first);
      xfer += _iter55->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ClientResponse::ascii_fingerprint = "7E7256E36D1891F8E99EC3F2E53069C6";
const uint8_t ClientResponse::binary_fingerprint[16] = {0x7E,0x72,0x56,0xE3,0x6D,0x18,0x91,0xF8,0xE9,0x9E,0xC3,0xF2,0xE5,0x30,0x69,0xC6};

uint32_t ClientResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->producerResponse.read(iprot);
          this->__isset.producerResponse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->consumerResponse.read(iprot);
          this->__isset.consumerResponse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClientResponse");
  xfer += oprot->writeFieldBegin("producerResponse", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->producerResponse.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("consumerResponse", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->consumerResponse.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HeartBeatRequest::ascii_fingerprint = "8F285C5968983B9695BF8B2EDA0C4EAD";
const uint8_t HeartBeatRequest::binary_fingerprint[16] = {0x8F,0x28,0x5C,0x59,0x68,0x98,0x3B,0x96,0x95,0xBF,0x8B,0x2E,0xDA,0x0C,0x4E,0xAD};

uint32_t HeartBeatRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast56;
          xfer += iprot->readI32(ecast56);
          this->clientRole = (ClientRole::type)ecast56;
          this->__isset.clientRole = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->heartbeatTime);
          this->__isset.heartbeatTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clientInfo.read(iprot);
          this->__isset.clientInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clientConfig.read(iprot);
          this->__isset.clientConfig = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HeartBeatRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HeartBeatRequest");
  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("clientRole", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->clientRole);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("heartbeatTime", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->heartbeatTime);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("clientInfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->clientInfo.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("clientConfig", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->clientConfig.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HeartBeatResponse::ascii_fingerprint = "B3D21B701EF62E61508F5C3AEB6BB10A";
const uint8_t HeartBeatResponse::binary_fingerprint[16] = {0xB3,0xD2,0x1B,0x70,0x1E,0xF6,0x2E,0x61,0x50,0x8F,0x5C,0x3A,0xEB,0x6B,0xB1,0x0A};

uint32_t HeartBeatResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast57;
          xfer += iprot->readI32(ecast57);
          this->errorCode = (ErrorCode::type)ecast57;
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clientResponse.read(iprot);
          this->__isset.clientResponse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HeartBeatResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HeartBeatResponse");
  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->errorCode);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("clientResponse", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->clientResponse.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ClientInfoRequest::ascii_fingerprint = "C75690EE49518353886426C3D96DB33D";
const uint8_t ClientInfoRequest::binary_fingerprint[16] = {0xC7,0x56,0x90,0xEE,0x49,0x51,0x83,0x53,0x88,0x64,0x26,0xC3,0xD9,0x6D,0xB3,0x3D};

uint32_t ClientInfoRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast58;
          xfer += iprot->readI32(ecast58);
          this->clientRole = (ClientRole::type)ecast58;
          this->__isset.clientRole = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster);
          this->__isset.cluster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          this->__isset.topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group);
          this->__isset.group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appkey);
          this->__isset.appkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientInfoRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClientInfoRequest");
  xfer += oprot->writeFieldBegin("clientRole", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->clientRole);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("cluster", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cluster);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->topic);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->group);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.appkey) {
    xfer += oprot->writeFieldBegin("appkey", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->appkey);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ProducerInfo::ascii_fingerprint = "F972067EEA735D41A447C0F8C4925135";
const uint8_t ProducerInfo::binary_fingerprint[16] = {0xF9,0x72,0x06,0x7E,0xEA,0x73,0x5D,0x41,0xA4,0x47,0xC0,0xF8,0xC4,0x92,0x51,0x35};

uint32_t ProducerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clientInfo.read(iprot);
          this->__isset.clientInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->modifyedTime);
          this->__isset.modifyedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProducerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ProducerInfo");
  xfer += oprot->writeFieldBegin("clientInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->clientInfo.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->createTime);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.modifyedTime) {
    xfer += oprot->writeFieldBegin("modifyedTime", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->modifyedTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ConsumerInfo::ascii_fingerprint = "A2897D244B0DA29D95D71D39E81AE73D";
const uint8_t ConsumerInfo::binary_fingerprint[16] = {0xA2,0x89,0x7D,0x24,0x4B,0x0D,0xA2,0x9D,0x95,0xD7,0x1D,0x39,0xE8,0x1A,0xE7,0x3D};

uint32_t ConsumerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clientInfo.read(iprot);
          this->__isset.clientInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTime);
          this->__isset.createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition);
          this->__isset.partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->modifyedTime);
          this->__isset.modifyedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConsumerInfo");
  xfer += oprot->writeFieldBegin("clientInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->clientInfo.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->createTime);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("partition", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->partition);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.modifyedTime) {
    xfer += oprot->writeFieldBegin("modifyedTime", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->modifyedTime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ClientPartitionInfo::ascii_fingerprint = "3A9091F94BF73CDFF768005EF54AB7A4";
const uint8_t ClientPartitionInfo::binary_fingerprint[16] = {0x3A,0x90,0x91,0xF9,0x4B,0xF7,0x3C,0xDF,0xF7,0x68,0x00,0x5E,0xF5,0x4A,0xB7,0xA4};

uint32_t ClientPartitionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clientInfo.read(iprot);
          this->__isset.clientInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition);
          this->__isset.partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createDTime);
          this->__isset.createDTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->modifyedTime);
          this->__isset.modifyedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast59;
          xfer += iprot->readI32(ecast59);
          this->clientRole = (ClientRole::type)ecast59;
          this->__isset.clientRole = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->threadId);
          this->__isset.threadId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster);
          this->__isset.cluster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientPartitionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClientPartitionInfo");
  xfer += oprot->writeFieldBegin("clientInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->clientInfo.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("partition", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->partition);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("createDTime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->createDTime);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("modifyedTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->modifyedTime);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("clientRole", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->clientRole);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("threadId", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->threadId);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("cluster", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->cluster);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TopicConfig::ascii_fingerprint = "8CED7D0196384D9CBED24F5EA594C819";
const uint8_t TopicConfig::binary_fingerprint[16] = {0x8C,0xED,0x7D,0x01,0x96,0x38,0x4D,0x9C,0xBE,0xD2,0x4F,0x5E,0xA5,0x94,0xC8,0x19};

uint32_t TopicConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topicName);
          this->__isset.topicName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appkey);
          this->__isset.appkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cluster.clear();
            uint32_t _size60;
            ::apache::thrift::protocol::TType _etype63;
            iprot->readListBegin(_etype63, _size60);
            this->cluster.resize(_size60);
            uint32_t _i64;
            for (_i64 = 0; _i64 < _size60; ++_i64)
            {
              xfer += iprot->readString(this->cluster[_i64]);
            }
            iprot->readListEnd();
          }
          this->__isset.cluster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition);
          this->__isset.partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->replica);
          this->__isset.replica = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast65;
          xfer += iprot->readI32(ecast65);
          this->sendType = (SendType::type)ecast65;
          this->__isset.sendType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ack);
          this->__isset.ack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sendSwitchEnable);
          this->__isset.sendSwitchEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->requestTimeOutMs);
          this->__isset.requestTimeOutMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queueMaxMs);
          this->__isset.queueMaxMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->queueMaxMessages);
          this->__isset.queueMaxMessages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->batchNumMessages);
          this->__isset.batchNumMessages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->messagSendFailMax);
          this->__isset.messagSendFailMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clusterName);
          this->__isset.clusterName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->idcSwitch);
          this->__isset.idcSwitch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mafkaConfigSource);
          this->__isset.mafkaConfigSource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sendMessageVersion);
          this->__isset.sendMessageVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopicConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopicConfig");
  xfer += oprot->writeFieldBegin("topicName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->topicName);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("appkey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->appkey);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("cluster", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cluster.size()));
    std::vector<std::string> ::const_iterator _iter66;
    for (_iter66 = this->cluster.begin(); _iter66 != this->cluster.end(); ++_iter66)
    {
      xfer += oprot->writeString((*_iter66));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("partition", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->partition);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("replica", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->replica);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("sendType", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->sendType);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ack", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->ack);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.sendSwitchEnable) {
    xfer += oprot->writeFieldBegin("sendSwitchEnable", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->sendSwitchEnable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.requestTimeOutMs) {
    xfer += oprot->writeFieldBegin("requestTimeOutMs", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->requestTimeOutMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queueMaxMs) {
    xfer += oprot->writeFieldBegin("queueMaxMs", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->queueMaxMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queueMaxMessages) {
    xfer += oprot->writeFieldBegin("queueMaxMessages", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->queueMaxMessages);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.batchNumMessages) {
    xfer += oprot->writeFieldBegin("batchNumMessages", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->batchNumMessages);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.messagSendFailMax) {
    xfer += oprot->writeFieldBegin("messagSendFailMax", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32(this->messagSendFailMax);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clusterName) {
    xfer += oprot->writeFieldBegin("clusterName", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->clusterName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.idcSwitch) {
    xfer += oprot->writeFieldBegin("idcSwitch", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->idcSwitch);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mafkaConfigSource) {
    xfer += oprot->writeFieldBegin("mafkaConfigSource", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->mafkaConfigSource);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sendMessageVersion) {
    xfer += oprot->writeFieldBegin("sendMessageVersion", ::apache::thrift::protocol::T_I32, 17);
    xfer += oprot->writeI32(this->sendMessageVersion);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ConsumerGroupConfig::ascii_fingerprint = "ACBDECED2C8B5AE0480AB82FE88FBF1D";
const uint8_t ConsumerGroupConfig::binary_fingerprint[16] = {0xAC,0xBD,0xEC,0xED,0x2C,0x8B,0x5A,0xE0,0x48,0x0A,0xB8,0x2F,0xE8,0x8F,0xBF,0x1D};

uint32_t ConsumerGroupConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic);
          this->__isset.topic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appkey);
          this->__isset.appkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->group);
          this->__isset.group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cluster.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            iprot->readListBegin(_etype70, _size67);
            this->cluster.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += iprot->readString(this->cluster[_i71]);
            }
            iprot->readListEnd();
          }
          this->__isset.cluster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topicAppkey);
          this->__isset.topicAppkey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clusterName);
          this->__isset.clusterName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->consumerThreadNum);
          this->__isset.consumerThreadNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->autoCommitEnable);
          this->__isset.autoCommitEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->autoCommitIntervalMs);
          this->__isset.autoCommitIntervalMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rebalanceMaxRetries);
          this->__isset.rebalanceMaxRetries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchMinBytes);
          this->__isset.fetchMinBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchWaitMaxMs);
          this->__isset.fetchWaitMaxMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->zookeeperSyncTimeMs);
          this->__isset.zookeeperSyncTimeMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rebalanceBackOffMs);
          this->__isset.rebalanceBackOffMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->autoOffsetReset);
          this->__isset.autoOffsetReset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->idcSwitch);
          this->__isset.idcSwitch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mafkaIdcSwitch);
          this->__isset.mafkaIdcSwitch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mafkaConfigSource);
          this->__isset.mafkaConfigSource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->consumerParallarNum);
          this->__isset.consumerParallarNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->consumeMessageDelay);
          this->__isset.consumeMessageDelay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumerGroupConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConsumerGroupConfig");
  xfer += oprot->writeFieldBegin("topic", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->topic);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("appkey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->appkey);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("group", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->group);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("cluster", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cluster.size()));
    std::vector<std::string> ::const_iterator _iter72;
    for (_iter72 = this->cluster.begin(); _iter72 != this->cluster.end(); ++_iter72)
    {
      xfer += oprot->writeString((*_iter72));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  if (this->__isset.topicAppkey) {
    xfer += oprot->writeFieldBegin("topicAppkey", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->topicAppkey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clusterName) {
    xfer += oprot->writeFieldBegin("clusterName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->clusterName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consumerThreadNum) {
    xfer += oprot->writeFieldBegin("consumerThreadNum", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->consumerThreadNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.autoCommitEnable) {
    xfer += oprot->writeFieldBegin("autoCommitEnable", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->autoCommitEnable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.autoCommitIntervalMs) {
    xfer += oprot->writeFieldBegin("autoCommitIntervalMs", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->autoCommitIntervalMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rebalanceMaxRetries) {
    xfer += oprot->writeFieldBegin("rebalanceMaxRetries", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->rebalanceMaxRetries);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fetchMinBytes) {
    xfer += oprot->writeFieldBegin("fetchMinBytes", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->fetchMinBytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fetchWaitMaxMs) {
    xfer += oprot->writeFieldBegin("fetchWaitMaxMs", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->fetchWaitMaxMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.zookeeperSyncTimeMs) {
    xfer += oprot->writeFieldBegin("zookeeperSyncTimeMs", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32(this->zookeeperSyncTimeMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rebalanceBackOffMs) {
    xfer += oprot->writeFieldBegin("rebalanceBackOffMs", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32(this->rebalanceBackOffMs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.autoOffsetReset) {
    xfer += oprot->writeFieldBegin("autoOffsetReset", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->autoOffsetReset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.idcSwitch) {
    xfer += oprot->writeFieldBegin("idcSwitch", ::apache::thrift::protocol::T_STRING, 16);
    xfer += oprot->writeString(this->idcSwitch);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mafkaIdcSwitch) {
    xfer += oprot->writeFieldBegin("mafkaIdcSwitch", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->mafkaIdcSwitch);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mafkaConfigSource) {
    xfer += oprot->writeFieldBegin("mafkaConfigSource", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->mafkaConfigSource);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consumerParallarNum) {
    xfer += oprot->writeFieldBegin("consumerParallarNum", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->consumerParallarNum);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.consumeMessageDelay) {
    xfer += oprot->writeFieldBegin("consumeMessageDelay", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32(this->consumeMessageDelay);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ClientInfoResponse::ascii_fingerprint = "3B169BD4679619E042BB4B3816A95C6E";
const uint8_t ClientInfoResponse::binary_fingerprint[16] = {0x3B,0x16,0x9B,0xD4,0x67,0x96,0x19,0xE0,0x42,0xBB,0x4B,0x38,0x16,0xA9,0x5C,0x6E};

uint32_t ClientInfoResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast73;
          xfer += iprot->readI32(ecast73);
          this->errorCode = (ErrorCode::type)ecast73;
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->producerInfoList.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            iprot->readListBegin(_etype77, _size74);
            this->producerInfoList.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += this->producerInfoList[_i78].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.producerInfoList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->consumerInfoList.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            iprot->readListBegin(_etype82, _size79);
            this->consumerInfoList.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += this->consumerInfoList[_i83].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.consumerInfoList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->mqClientInfoList.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            iprot->readListBegin(_etype87, _size84);
            this->mqClientInfoList.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->mqClientInfoList[_i88].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.mqClientInfoList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClientInfoResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClientInfoResponse");
  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->errorCode);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("producerInfoList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->producerInfoList.size()));
    std::vector<ProducerInfo> ::const_iterator _iter89;
    for (_iter89 = this->producerInfoList.begin(); _iter89 != this->producerInfoList.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("consumerInfoList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->consumerInfoList.size()));
    std::vector<ConsumerInfo> ::const_iterator _iter90;
    for (_iter90 = this->consumerInfoList.begin(); _iter90 != this->consumerInfoList.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  if (this->__isset.mqClientInfoList) {
    xfer += oprot->writeFieldBegin("mqClientInfoList", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->mqClientInfoList.size()));
      std::vector<ClientPartitionInfo> ::const_iterator _iter91;
      for (_iter91 = this->mqClientInfoList.begin(); _iter91 != this->mqClientInfoList.end(); ++_iter91)
      {
        xfer += (*_iter91).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TopicStatistic::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t TopicStatistic::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t TopicStatistic::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->messageCount);
          this->__isset.messageCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->produceRate);
          this->__isset.produceRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopicStatistic::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopicStatistic");
  xfer += oprot->writeFieldBegin("messageCount", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->messageCount);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("produceRate", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->produceRate);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* GroupStatistic::ascii_fingerprint = "66C8E6F97F0275919D86FEB536251B17";
const uint8_t GroupStatistic::binary_fingerprint[16] = {0x66,0xC8,0xE6,0xF9,0x7F,0x02,0x75,0x91,0x9D,0x86,0xFE,0xB5,0x36,0x25,0x1B,0x17};

uint32_t GroupStatistic::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->accumulation);
          this->__isset.accumulation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->consumeRate);
          this->__isset.consumeRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->logSize);
          this->__isset.logSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GroupStatistic::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GroupStatistic");
  xfer += oprot->writeFieldBegin("accumulation", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->accumulation);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("consumeRate", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->consumeRate);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("logSize", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->logSize);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* PartitionInfo::ascii_fingerprint = "8C35DF6AC9EEB3CE6791D97AB2AB1167";
const uint8_t PartitionInfo::binary_fingerprint[16] = {0x8C,0x35,0xDF,0x6A,0xC9,0xEE,0xB3,0xCE,0x67,0x91,0xD9,0x7A,0xB2,0xAB,0x11,0x67};

uint32_t PartitionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partitionId);
          this->__isset.partitionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->topicPartitionInfo.read(iprot);
          this->__isset.topicPartitionInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->groupPartitionInfo.read(iprot);
          this->__isset.groupPartitionInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PartitionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PartitionInfo");
  xfer += oprot->writeFieldBegin("partitionId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->partitionId);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("topicPartitionInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->topicPartitionInfo.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("groupPartitionInfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->groupPartitionInfo.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TopicMonitorInfo::ascii_fingerprint = "BE1AD48E4A75C9E0758E9D2AA5263585";
const uint8_t TopicMonitorInfo::binary_fingerprint[16] = {0xBE,0x1A,0xD4,0x8E,0x4A,0x75,0xC9,0xE0,0x75,0x8E,0x9D,0x2A,0xA5,0x26,0x35,0x85};

uint32_t TopicMonitorInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->topicPartitionInfoList.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            iprot->readListBegin(_etype95, _size92);
            this->topicPartitionInfoList.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += this->topicPartitionInfoList[_i96].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.topicPartitionInfoList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->topicStatic.read(iprot);
          this->__isset.topicStatic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopicMonitorInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopicMonitorInfo");
  xfer += oprot->writeFieldBegin("topicPartitionInfoList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->topicPartitionInfoList.size()));
    std::vector<PartitionInfo> ::const_iterator _iter97;
    for (_iter97 = this->topicPartitionInfoList.begin(); _iter97 != this->topicPartitionInfoList.end(); ++_iter97)
    {
      xfer += (*_iter97).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("topicStatic", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->topicStatic.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ConsumerGroupMonitorInfo::ascii_fingerprint = "45E0F06ABBE9DCC1D14C83167C08F1C5";
const uint8_t ConsumerGroupMonitorInfo::binary_fingerprint[16] = {0x45,0xE0,0xF0,0x6A,0xBB,0xE9,0xDC,0xC1,0xD1,0x4C,0x83,0x16,0x7C,0x08,0xF1,0xC5};

uint32_t ConsumerGroupMonitorInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionInfoList.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            iprot->readListBegin(_etype101, _size98);
            this->partitionInfoList.resize(_size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              xfer += this->partitionInfoList[_i102].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.partitionInfoList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->groupStatistic.read(iprot);
          this->__isset.groupStatistic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumerGroupMonitorInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConsumerGroupMonitorInfo");
  xfer += oprot->writeFieldBegin("partitionInfoList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionInfoList.size()));
    std::vector<PartitionInfo> ::const_iterator _iter103;
    for (_iter103 = this->partitionInfoList.begin(); _iter103 != this->partitionInfoList.end(); ++_iter103)
    {
      xfer += (*_iter103).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("groupStatistic", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->groupStatistic.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TopicInfo::ascii_fingerprint = "17BA584FD1C0E73C97BAED1804F6295E";
const uint8_t TopicInfo::binary_fingerprint[16] = {0x17,0xBA,0x58,0x4F,0xD1,0xC0,0xE7,0x3C,0x97,0xBA,0xED,0x18,0x04,0xF6,0x29,0x5E};

uint32_t TopicInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->topicConfig.read(iprot);
          this->__isset.topicConfig = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->topicMonitorInfo.read(iprot);
          this->__isset.topicMonitorInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopicInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopicInfo");
  xfer += oprot->writeFieldBegin("topicConfig", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->topicConfig.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("topicMonitorInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->topicMonitorInfo.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ConsumerGroupInfo::ascii_fingerprint = "46CFAE7A0DBFAA2D9D02016260D64024";
const uint8_t ConsumerGroupInfo::binary_fingerprint[16] = {0x46,0xCF,0xAE,0x7A,0x0D,0xBF,0xAA,0x2D,0x9D,0x02,0x01,0x62,0x60,0xD6,0x40,0x24};

uint32_t ConsumerGroupInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->consumerGroupConfig.read(iprot);
          this->__isset.consumerGroupConfig = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->consumerGroupMonitorInfo.read(iprot);
          this->__isset.consumerGroupMonitorInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumerGroupInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConsumerGroupInfo");
  xfer += oprot->writeFieldBegin("consumerGroupConfig", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->consumerGroupConfig.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("consumerGroupMonitorInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->consumerGroupMonitorInfo.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TopicConfigRequest::ascii_fingerprint = "E9F7A362A1C1148C1832D2C9C1789088";
const uint8_t TopicConfigRequest::binary_fingerprint[16] = {0xE9,0xF7,0xA3,0x62,0xA1,0xC1,0x14,0x8C,0x18,0x32,0xD2,0xC9,0xC1,0x78,0x90,0x88};

uint32_t TopicConfigRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->topicConfig.read(iprot);
          this->__isset.topicConfig = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast104;
          xfer += iprot->readI32(ecast104);
          this->requestType = (RequestType::type)ecast104;
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopicConfigRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopicConfigRequest");
  xfer += oprot->writeFieldBegin("topicConfig", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->topicConfig.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->requestType);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TopicActionResponse::ascii_fingerprint = "8BBB3D0C3B370CB38F2D1340BB79F0AA";
const uint8_t TopicActionResponse::binary_fingerprint[16] = {0x8B,0xBB,0x3D,0x0C,0x3B,0x37,0x0C,0xB3,0x8F,0x2D,0x13,0x40,0xBB,0x79,0xF0,0xAA};

uint32_t TopicActionResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast105;
          xfer += iprot->readI32(ecast105);
          this->errocode = (ErrorCode::type)ecast105;
          this->__isset.errocode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopicActionResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopicActionResponse");
  xfer += oprot->writeFieldBegin("errocode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->errocode);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TopicConfigResponse::ascii_fingerprint = "BD96FCA5749F01DA5CDBF2BC74E91ABC";
const uint8_t TopicConfigResponse::binary_fingerprint[16] = {0xBD,0x96,0xFC,0xA5,0x74,0x9F,0x01,0xDA,0x5C,0xDB,0xF2,0xBC,0x74,0xE9,0x1A,0xBC};

uint32_t TopicConfigResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast106;
          xfer += iprot->readI32(ecast106);
          this->errocode = (ErrorCode::type)ecast106;
          this->__isset.errocode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->topicConfig.read(iprot);
          this->__isset.topicConfig = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopicConfigResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopicConfigResponse");
  xfer += oprot->writeFieldBegin("errocode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->errocode);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("topicConfig", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->topicConfig.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TopicInfoResponse::ascii_fingerprint = "AF13CCAE77296557B67493182BCB1B5C";
const uint8_t TopicInfoResponse::binary_fingerprint[16] = {0xAF,0x13,0xCC,0xAE,0x77,0x29,0x65,0x57,0xB6,0x74,0x93,0x18,0x2B,0xCB,0x1B,0x5C};

uint32_t TopicInfoResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast107;
          xfer += iprot->readI32(ecast107);
          this->errocode = (ErrorCode::type)ecast107;
          this->__isset.errocode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->topicInfo.read(iprot);
          this->__isset.topicInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopicInfoResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopicInfoResponse");
  xfer += oprot->writeFieldBegin("errocode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->errocode);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("topicInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->topicInfo.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ConsumerGroupConfigRequest::ascii_fingerprint = "1F4313910A9362DEC6ACE5A62A997CE4";
const uint8_t ConsumerGroupConfigRequest::binary_fingerprint[16] = {0x1F,0x43,0x13,0x91,0x0A,0x93,0x62,0xDE,0xC6,0xAC,0xE5,0xA6,0x2A,0x99,0x7C,0xE4};

uint32_t ConsumerGroupConfigRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->consumerGroupConfig.read(iprot);
          this->__isset.consumerGroupConfig = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast108;
          xfer += iprot->readI32(ecast108);
          this->requestType = (RequestType::type)ecast108;
          this->__isset.requestType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumerGroupConfigRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConsumerGroupConfigRequest");
  xfer += oprot->writeFieldBegin("consumerGroupConfig", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->consumerGroupConfig.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("requestType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->requestType);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ConsumerGroupInfoResponse::ascii_fingerprint = "269EBBFD0DA2208825B51BE3B763932C";
const uint8_t ConsumerGroupInfoResponse::binary_fingerprint[16] = {0x26,0x9E,0xBB,0xFD,0x0D,0xA2,0x20,0x88,0x25,0xB5,0x1B,0xE3,0xB7,0x63,0x93,0x2C};

uint32_t ConsumerGroupInfoResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast109;
          xfer += iprot->readI32(ecast109);
          this->errocode = (ErrorCode::type)ecast109;
          this->__isset.errocode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->consumerGroupInfo.read(iprot);
          this->__isset.consumerGroupInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumerGroupInfoResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConsumerGroupInfoResponse");
  xfer += oprot->writeFieldBegin("errocode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->errocode);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("consumerGroupInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->consumerGroupInfo.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* TopicInfoListResponse::ascii_fingerprint = "89AD62DC37C7F27DD2098FDCECFF5AE2";
const uint8_t TopicInfoListResponse::binary_fingerprint[16] = {0x89,0xAD,0x62,0xDC,0x37,0xC7,0xF2,0x7D,0xD2,0x09,0x8F,0xDC,0xEC,0xFF,0x5A,0xE2};

uint32_t TopicInfoListResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast110;
          xfer += iprot->readI32(ecast110);
          this->errocode = (ErrorCode::type)ecast110;
          this->__isset.errocode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->topicInfoList.clear();
            uint32_t _size111;
            ::apache::thrift::protocol::TType _etype114;
            iprot->readListBegin(_etype114, _size111);
            this->topicInfoList.resize(_size111);
            uint32_t _i115;
            for (_i115 = 0; _i115 < _size111; ++_i115)
            {
              xfer += this->topicInfoList[_i115].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.topicInfoList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopicInfoListResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TopicInfoListResponse");
  xfer += oprot->writeFieldBegin("errocode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->errocode);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("topicInfoList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->topicInfoList.size()));
    std::vector<TopicInfo> ::const_iterator _iter116;
    for (_iter116 = this->topicInfoList.begin(); _iter116 != this->topicInfoList.end(); ++_iter116)
    {
      xfer += (*_iter116).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ConsumerGroupListResponse::ascii_fingerprint = "7820CD79C11BC2AF60561C7D74261F6B";
const uint8_t ConsumerGroupListResponse::binary_fingerprint[16] = {0x78,0x20,0xCD,0x79,0xC1,0x1B,0xC2,0xAF,0x60,0x56,0x1C,0x7D,0x74,0x26,0x1F,0x6B};

uint32_t ConsumerGroupListResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast117;
          xfer += iprot->readI32(ecast117);
          this->errocode = (ErrorCode::type)ecast117;
          this->__isset.errocode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->consumerGroupInfoList.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            iprot->readListBegin(_etype121, _size118);
            this->consumerGroupInfoList.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += this->consumerGroupInfoList[_i122].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.consumerGroupInfoList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumerGroupListResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ConsumerGroupListResponse");
  xfer += oprot->writeFieldBegin("errocode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->errocode);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("consumerGroupInfoList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->consumerGroupInfoList.size()));
    std::vector<ConsumerGroupInfo> ::const_iterator _iter123;
    for (_iter123 = this->consumerGroupInfoList.begin(); _iter123 != this->consumerGroupInfoList.end(); ++_iter123)
    {
      xfer += (*_iter123).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* ClusterNameRequest::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t ClusterNameRequest::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t ClusterNameRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cluster);
          this->__isset.cluster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClusterNameRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClusterNameRequest");
  xfer += oprot->writeFieldBegin("cluster", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->cluster);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


