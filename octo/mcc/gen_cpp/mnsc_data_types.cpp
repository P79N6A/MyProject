/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mnsc_data_types.h"



const char* MNSResponse::ascii_fingerprint = "607E13C093F57A1B6FDE8C4DB92A8534";
const uint8_t MNSResponse::binary_fingerprint[16] = {0x60,0x7E,0x13,0xC0,0x93,0xF5,0x7A,0x1B,0x6F,0xDE,0x8C,0x4D,0xB9,0x2A,0x85,0x34};

uint32_t MNSResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->defaultMNSCache.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            iprot->readListBegin(_etype3, _size0);
            this->defaultMNSCache.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->defaultMNSCache[_i4].read(iprot);
            }
            iprot->readListEnd();
          }
          this->__isset.defaultMNSCache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MNSResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MNSResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.defaultMNSCache) {
    xfer += oprot->writeFieldBegin("defaultMNSCache", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->defaultMNSCache.size()));
      std::vector<SGService> ::const_iterator _iter5;
      for (_iter5 = this->defaultMNSCache.begin(); _iter5 != this->defaultMNSCache.end(); ++_iter5)
      {
        xfer += (*_iter5).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.version) {
    xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->version);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* AppKeyListResponse::ascii_fingerprint = "93CC3D1E71866966C22792AABF4C3815";
const uint8_t AppKeyListResponse::binary_fingerprint[16] = {0x93,0xCC,0x3D,0x1E,0x71,0x86,0x69,0x66,0xC2,0x27,0x92,0xAA,0xBF,0x4C,0x38,0x15};

uint32_t AppKeyListResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->appKeyList.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            iprot->readListBegin(_etype9, _size6);
            this->appKeyList.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readString(this->appKeyList[_i10]);
            }
            iprot->readListEnd();
          }
          this->__isset.appKeyList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t AppKeyListResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AppKeyListResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.appKeyList) {
    xfer += oprot->writeFieldBegin("appKeyList", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->appKeyList.size()));
      std::vector<std::string> ::const_iterator _iter11;
      for (_iter11 = this->appKeyList.begin(); _iter11 != this->appKeyList.end(); ++_iter11)
      {
        xfer += oprot->writeString((*_iter11));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* HttpPropertiesResponse::ascii_fingerprint = "ED513D89046EBA5323735F654E017436";
const uint8_t HttpPropertiesResponse::binary_fingerprint[16] = {0xED,0x51,0x3D,0x89,0x04,0x6E,0xBA,0x53,0x23,0x73,0x5F,0x65,0x4E,0x01,0x74,0x36};

uint32_t HttpPropertiesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->propertiesMap.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _ktype13;
            ::apache::thrift::protocol::TType _vtype14;
            iprot->readMapBegin(_ktype13, _vtype14, _size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              std::string _key17;
              xfer += iprot->readString(_key17);
              HttpProperties& _val18 = this->propertiesMap[_key17];
              {
                _val18.clear();
                uint32_t _size19;
                ::apache::thrift::protocol::TType _ktype20;
                ::apache::thrift::protocol::TType _vtype21;
                iprot->readMapBegin(_ktype20, _vtype21, _size19);
                uint32_t _i23;
                for (_i23 = 0; _i23 < _size19; ++_i23)
                {
                  std::string _key24;
                  xfer += iprot->readString(_key24);
                  std::string& _val25 = _val18[_key24];
                  xfer += iprot->readString(_val25);
                }
                iprot->readMapEnd();
              }
            }
            iprot->readMapEnd();
          }
          this->__isset.propertiesMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t HttpPropertiesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HttpPropertiesResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.propertiesMap) {
    xfer += oprot->writeFieldBegin("propertiesMap", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->propertiesMap.size()));
      std::map<std::string, HttpProperties> ::const_iterator _iter26;
      for (_iter26 = this->propertiesMap.begin(); _iter26 != this->propertiesMap.end(); ++_iter26)
      {
        xfer += oprot->writeString(_iter26->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter26->second.size()));
          std::map<std::string, std::string> ::const_iterator _iter27;
          for (_iter27 = _iter26->second.begin(); _iter27 != _iter26->second.end(); ++_iter27)
          {
            xfer += oprot->writeString(_iter27->first);
            xfer += oprot->writeString(_iter27->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const char* UpstreamResponse::ascii_fingerprint = "20A57526680CA4CBC28C94966623FAC2";
const uint8_t UpstreamResponse::binary_fingerprint[16] = {0x20,0xA5,0x75,0x26,0x68,0x0C,0xA4,0xCB,0xC2,0x8C,0x94,0x96,0x66,0x23,0xFA,0xC2};

uint32_t UpstreamResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->upstreams.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _ktype29;
            ::apache::thrift::protocol::TType _vtype30;
            iprot->readMapBegin(_ktype29, _vtype30, _size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              std::string _key33;
              xfer += iprot->readString(_key33);
              std::string& _val34 = this->upstreams[_key33];
              xfer += iprot->readString(_val34);
            }
            iprot->readMapEnd();
          }
          this->__isset.upstreams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ext);
          this->__isset.ext = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t UpstreamResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpstreamResponse");
  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("upstreams", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->upstreams.size()));
    std::map<std::string, std::string> ::const_iterator _iter35;
    for (_iter35 = this->upstreams.begin(); _iter35 != this->upstreams.end(); ++_iter35)
    {
      xfer += oprot->writeString(_iter35->first);
      xfer += oprot->writeString(_iter35->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("ext", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ext);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


