akka {

  actor.provider = "akka.cluster.ClusterActorRefProvider"

  remote.netty.tcp.port = 2552
  remote.netty.tcp.hostname = 127.0.0.1

  cluster {
    seed-nodes = ["akka.tcp://LogClusterSystem@10.21.246.230:2552",
      "akka.tcp://LogClusterSystem@10.22.26.244:2552"]
  }

  extensions = ["akka.cluster.client.ClusterClientReceptionist",
    "com.romix.akka.serialization.kryo.KryoSerializationExtension$"]

  loggers = ["akka.event.slf4j.Slf4jLogger"]
  loglevel = DEBUG
  log-config-on-start = on

  actor {
    debug {
      receive = on
      autoreceive = on
      lifecycle = on
      fsm = on
      event-stream = on
      unhandled = on
      router-misconfiguration = on
    }
  }

  # Serialization
  actor {
    serializers {
      java = "akka.serialization.JavaSerializer"
      # Define kryo serializer
      kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
    }

    serialization-bindings {
      "java.io.Serializable" = kryo
      "scala.Serializable" = kryo
      "scala.Product" = kryo
    }
  }

  # kryo serialization
  actor {
    kryo {

      kryo-custom-serializer-init = "com.sankuai.octo.log.utils.KryoInit"
      # Possibles values for type are: graph or nograph
      # graph supports serialization of object graphs with shared nodes
      # and cyclic references, but this comes at the expense of a small overhead
      # nograph does not support object grpahs with shared nodes, but is usually faster
      type = "nograph"


      # Possible values for idstrategy are:
      # default, explicit, incremental, automatic
      #
      # default - slowest and produces bigger serialized representation. Contains fully-
      # qualified class names (FQCNs) for each class
      #
      # explicit - fast and produces compact serialized representation. Requires that all
      # classes that will be serialized are pre-registered using the "mappings" and "classes"
      # sections. To guarantee that both sender and receiver use the same numeric ids for the same
      # classes it is advised to provide exactly the same entries in the "mappings" section
      #
      # incremental - fast and produces compact serialized representation. Support optional
      # pre-registering of classes using the "mappings" and "classes" sections. If class is
      # not pre-registered, it will be registered dynamically by picking a next available id
      # To guarantee that both sender and receiver use the same numeric ids for the same
      # classes it is advised to pre-register them using at least the "classes" section
      #
      # automatic - Contains fully-qualified class names (FQCNs) for each class that is not
      # pre-registered in the "mappings" and "classes" section

      idstrategy = "automatic"

      # If set, akka uses manifests to put a class name
      # of the top-level object into each message
      use-manifests = false

      # Enable transparent compression of serialized messages
      # accepted values are: off | lz4 | deflate
      compression = lz4

      # Log implicitly registered classes. Useful, if you want to know all classes
      # which are serialized
      implicit-registration-logging = true

      # If enabled, Kryo logs a lot of information about serialization process.
      # Useful for debugging and lowl-level tweaking
      kryo-trace = false

      # If enabled, Kryo uses internally a map detecting shared nodes.
      # This is a preferred mode for big object graphs with a lot of nodes.
      # For small object graphs (e.g. below 10 nodes) set it to false for
      # better performance.
      kryo-reference-map = false

      # Define mappings from a fully qualified class name to a numeric id.
      # Smaller ids lead to smaller sizes of serialized representations.
      #
      # This section is mandatory for idstartegy=explicit
      # This section is optional  for idstartegy=incremental
      # This section is ignored   for idstartegy=default
      #
      # The smallest possible id should start at 20 (or even higher), because
      # ids below it are used by Kryo internally e.g. for built-in Java and
      # Scala types
      mappings {
        # scala 内部类型
        "[B" = 101,
        "scala.collection.immutable.Vector" = 102,
        "scala.collection.immutable.List" = 103,
        "scala.collection.immutable.Set" = 104,
        "scala.collection.immutable.Set$Set1" = 105,
        "scala.Some" = 106,
        "scala.Enumeration$Val" = 107,
        "scala.Enumeration$Value" = 108,

        # akka 类型
        "akka.actor.LocalActorRef" = 201,
        "akka.actor.Identify" = 202,
        "akka.actor.ActorIdentity" = 203,
        "akka.actor.Address" = 204,
        "akka.actor.RepointableActorRef" = 205,

        # akka cluster类型
        "akka.cluster.ClusterHeartbeatSender" = 301,
        "akka.cluster.ClusterHeartbeatSender$Heartbeat" = 302,
        "akka.cluster.ClusterHeartbeatSender$HeartbeatRsp" = 303,
        "akka.cluster.InternalClusterAction" = 304,
        "akka.cluster.InternalClusterAction$InitJoin$" = 305,
        "akka.cluster.UniqueAddress" = 306,

        # akka cluster pubsub类型
        "akka.cluster.pubsub.DistributedPubSubMediator" = 401,
        "akka.cluster.pubsub.DistributedPubSubMediator$Internal$" = 402,
        "akka.cluster.pubsub.DistributedPubSubMediator$Internal$Delta" = 403,
        "akka.cluster.pubsub.DistributedPubSubMediator$Internal$Bucket" = 404,
        "akka.cluster.pubsub.DistributedPubSubMediator$Internal$ValueHolder" = 405,
        "akka.cluster.pubsub.DistributedPubSubMediator$Internal$Status" = 406,
        "akka.cluster.pubsub.DistributedPubSubMediator$Send" = 407,
        "akka.cluster.pubsub.DistributedPubSubMediator$SendToAll" = 408,


        # akka cluster client类型
        "akka.cluster.client.ClusterReceptionist" = 501,
        "akka.cluster.client.ClusterReceptionist$Internal$" = 502,
        "akka.cluster.client.ClusterReceptionist$Internal$GetContacts$" = 503,
        "akka.cluster.client.ClusterReceptionist$Internal$Contacts" = 504,
        "akka.cluster.client.ClusterReceptionist$Internal$Heartbeat$" = 505,
        "akka.cluster.client.ClusterReceptionist$Internal$HeartbeatRsp$" = 506,

        # 应用内部类型
        "com.sankuai.octo.log.Protocol" = 601,
        "com.sankuai.octo.log.Protocol$RegisterClient" = 602,
        "com.sankuai.octo.log.Protocol$WatchInfo" = 603,
        "com.sankuai.octo.log.Protocol$ClientUUID" = 604,
        "com.sankuai.octo.log.Protocol$ClientUUIDWatchInfo" = 605,
        "com.sankuai.octo.log.Protocol$WatchCmd$" = 606,
        "com.sankuai.octo.log.Protocol$WatchAction" = 607,
        "com.sankuai.octo.log.Protocol$LogMsg" = 608,
        "com.sankuai.octo.log.Protocol$LogResult" = 609,


      }

      # Define a set of fully qualified class names for
      # classes to be used for serialization.
      # The ids for those classes will be assigned automatically,
      # but respecting the order of declaration in this section
      #
      # This section is optional  for idstartegy=incremental
      # This section is ignored   for idstartegy=default
      # This section is optional  for idstartegy=explicit
      classes = [
        # scala 内部类型
        "[B",
        "scala.collection.immutable.Vector",
        "scala.collection.immutable.List",
        "scala.collection.immutable.Set",
        "scala.collection.immutable.Set$Set1",
        "scala.Some",
        "scala.Enumeration$Val",
        "scala.Enumeration$Value",

        # akka 类型
        "akka.actor.LocalActorRef",
        "akka.actor.Identify",
        "akka.actor.ActorIdentity",
        "akka.actor.Address",
        "akka.actor.RepointableActorRef",

        # akka cluster类型
        "akka.cluster.ClusterHeartbeatSender",
        "akka.cluster.ClusterHeartbeatSender$Heartbeat",
        "akka.cluster.ClusterHeartbeatSender$HeartbeatRsp",
        "akka.cluster.InternalClusterAction",
        "akka.cluster.InternalClusterAction$InitJoin$",
        "akka.cluster.UniqueAddress",

        # akka cluster pubsub类型
        "akka.cluster.pubsub.DistributedPubSubMediator",
        "akka.cluster.pubsub.DistributedPubSubMediator$Internal$",
        "akka.cluster.pubsub.DistributedPubSubMediator$Internal$Delta",
        "akka.cluster.pubsub.DistributedPubSubMediator$Internal$Bucket",
        "akka.cluster.pubsub.DistributedPubSubMediator$Internal$ValueHolder",
        "akka.cluster.pubsub.DistributedPubSubMediator$Internal$Status",
        "akka.cluster.pubsub.DistributedPubSubMediator$Send",
        "akka.cluster.pubsub.DistributedPubSubMediator$SendToAll",


        # akka cluster client类型
        "akka.cluster.client.ClusterReceptionist",
        "akka.cluster.client.ClusterReceptionist$Internal$",
        "akka.cluster.client.ClusterReceptionist$Internal$GetContacts$",
        "akka.cluster.client.ClusterReceptionist$Internal$Contacts",
        "akka.cluster.client.ClusterReceptionist$Internal$Heartbeat$",
        "akka.cluster.client.ClusterReceptionist$Internal$HeartbeatRsp$",

        # 应用内部类型
        "com.sankuai.octo.log.Protocol",
        "com.sankuai.octo.log.Protocol$RegisterClient",
        "com.sankuai.octo.log.Protocol$WatchInfo",
        "com.sankuai.octo.log.Protocol$ClientUUID",
        "com.sankuai.octo.log.Protocol$ClientUUIDWatchInfo",
        "com.sankuai.octo.log.Protocol$WatchCmd$",
        "com.sankuai.octo.log.Protocol$WatchAction",
        "com.sankuai.octo.log.Protocol$LogMsg",
        "com.sankuai.octo.log.Protocol$LogResult",

      ]
    }
  }

}
